---
sidebar_position: 3
id: implement-grpc
title: Implement a gRPC API
description: "Transform Your Go API Building Game with Buf and Connect: Create Lightning-Fast, Efficient, and Effortless
APIs in Just 15 Minutes!"
---

gRPC is an open-source framework for building remote procedure call (RPC) APIs with high performance. It uses the
Protocol Buffers data format for efficient serialization, and supports a variety of programming languages. This
framework offers several features that make it a popular choice for building microservice architectures and large-scale
networked systems, such as bidirectional streaming, flow control, and automatic generation of client and server code.
The efficient and scalable design of gRPC allows developers to create fast and robust APIs, making it a must-have tool
for anyone looking to step up their API game. Whether you're building a microservice or a large-scale system, gRPC
provides a comprehensive solution that will help you achieve your goals efficiently and effectively.

## Prerequisites

* You'll need one of the [last two major releases][go-releases] of Go, with a minimum of Go 1.18. See
  Go's [Getting Started][install-go] guide for installation instructions.

## Install tools

First, we'll need to create a new Go module and install some code generation tools:

```terminal
$ go install github.com/bufbuild/buf/cmd/buf@latest
$ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
```

You'll need `buf`, `protoc-gen-go` and `protoc-gen-go-grpc` on your `PATH`.
If `which buf protoc-gen-go protoc-gen-go-grpc` doesn't succeed, add Go's install directories to your path:

```terminal
$ [ -n "$(go env GOBIN)" ] && export PATH="$(go env GOBIN):${PATH}"
$ [ -n "$(go env GOPATH)" ] && export PATH="$(go env GOPATH)/bin:${PATH}"
```

## 1. Generate code

We're going to generate our code using [Buf][buf], a modern replacement for Google's protobuf compiler. We installed Buf
earlier, but we also need a few configuration files to get going. (If you'd prefer, you can skip this section and
use `protoc` instead &mdash; `protoc-gen-grpc-go` behaves like any other plugin.)

Next, tell Buf how to generate code by putting this into [`buf.gen.yaml`][buf.gen.yaml]:

```yaml
version: v1
plugins:
  - name: go
    out: gen
    opt: paths=source_relative
  - name: go-grpc
    out: gen
    opt: paths=source_relative
```

With our configuration files in place, you can generate code:

```terminal
$ buf generate
```

In your `gen` directory, you should now see some generated Go:

```
gen
â””â”€â”€ greet
    â””â”€â”€ v1
        â”œâ”€â”€ greet.pb.go
        â””â”€â”€ greetv1connect
            â””â”€â”€ greet.connect.go
```

The package `gen/greet/v1` contains `greet.pb.go`, which was generated by Google's `protoc-gen-go`, and it contains
the `GreetRequest` and `GreetResponse` structs and the associated marshaling code. The
package `gen/greet/v1/` contains `greet.grpc.pb.go`, which was generated by `protoc-gen-grpc-go`, and
it contains the HTTP handler and client interfaces and constructors.

:::caution ðŸš§ Under construction
include comment about virtually unreadable generated code
:::

## 1. Implement the server {#implement-the-server}

You can start implementing a server by creating a `server/main.go` file:

```terminal
$ mkdir server
$ touch server/main.go
```

Copy and paste this content into that file:

```go title="server/main.go"
package main

import (
	"context"
	"fmt"
	"log"
	"net"

	// This import path is based on the name declaration in the go.mod,
	// and the gen/proto/go output location in the buf.gen.yaml.
	petv1 "github.com/bufbuild/buf-tour/petstore/gen/proto/go/pet/v1"
	"google.golang.org/grpc"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	listenOn := "127.0.0.1:8080"
	listener, err := net.Listen("tcp", listenOn)
	if err != nil {
		return fmt.Errorf("failed to listen on %s: %w", listenOn, err)
	}

	server := grpc.NewServer()
	petv1.RegisterPetStoreServiceServer(server, &petStoreServiceServer{})
	log.Println("Listening on", listenOn)
	if err := server.Serve(listener); err != nil {
		return fmt.Errorf("failed to serve gRPC server: %w", err)
	}

	return nil
}

// petStoreServiceServer implements the PetStoreService API.
type petStoreServiceServer struct {
	petv1.UnimplementedPetStoreServiceServer
}

// PutPet adds the pet associated with the given request into the PetStore.
func (s *petStoreServiceServer) PutPet(ctx context.Context, req *petv1.PutPetRequest) (*petv1.PutPetResponse, error) {
	name := req.GetName()
	petType := req.GetPetType()
	log.Println("Got a request to create a", petType, "named", name)

	return &petv1.PutPetResponse{}, nil
}
```

:::caution ðŸš§ Under construction
include grpcurl call
:::

## 1. Implement the client {#implement-the-client}

You can start implementing a client by creating a `client/main.go` file:

```terminal
$ mkdir client
$ touch client/main.go
```

Copy and paste this content into that file:

```go title="client/main.go"
package main

import (
	"context"
	"fmt"
	"log"

	// This import path is based on the name declaration in the go.mod,
	// and the gen/proto/go output location in the buf.gen.yaml.
	petv1 "github.com/bufbuild/buf-tour/petstore/gen/proto/go/pet/v1"
	"google.golang.org/grpc"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}
func run() error {
	connectTo := "127.0.0.1:8080"
	conn, err := grpc.Dial(connectTo, grpc.WithBlock(), grpc.WithInsecure())
	if err != nil {
		return fmt.Errorf("failed to connect to PetStoreService on %s: %w", connectTo, err)
	}
	log.Println("Connected to", connectTo)

	petStore := petv1.NewPetStoreServiceClient(conn)
	if _, err := petStore.PutPet(context.Background(), &petv1.PutPetRequest{
		PetType: petv1.PetType_PET_TYPE_SNAKE,
		Name:    "Ekans",
	}); err != nil {
		return fmt.Errorf("failed to PutPet: %w", err)
	}

	log.Println("Successfully PutPet")
	return nil
}
```

## 1. Resolve Go dependencies {#resolve-go-dependencies}

Now that you have code for both a client and a server, run this command to
resolve some of the dependencies you need for the generated code:

```terminal
$ go mod tidy
```

You should notice these changes (the version pins may differ):

```sh title="go.mod" {4-9}
 module github.com/bufbuild/buf-tour/petstore

 go 1.16
+
+require (
+	google.golang.org/genproto v0.0.0-20210811021853-ddbe55d93216
+	google.golang.org/grpc v1.40.0
+	google.golang.org/protobuf v1.27.1
+)
```

## 1. Call `PutPet` {#call-putpet}

With the `server/main.go` and `client/main.go` implementations shown above, run
the server and call the `PutPet` endpoint from the client.

First, run the server:

```terminal
$ go run server/main.go
---
... Listening on 127.0.0.1:8080
```

In a separate terminal, run the client and you should see a success message:

```terminal
$ go run client/main.go
---
... Connected to 127.0.0.1:8080
... Successfully PutPet
```

You'll also notice this in the server logs (in the other terminal running the
server):

```terminal
$ go run server/main.go
---
... Listening on 127.0.0.1:8080
... Got a request to create a PET_TYPE_SNAKE named Ekans
```


## Next steps

import Feedback from './_feedback.mdx';

<Feedback/>