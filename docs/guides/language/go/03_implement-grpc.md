---
sidebar_position: 3
id: implement-grpc
title: Implement a gRPC API
description: "Transform Your Go API Building Game with Buf and Connect: Create Lightning-Fast, Efficient, and Effortless
APIs in Just 15 Minutes!"
---

gRPC is an open-source framework for building remote procedure call (RPC) APIs with high performance. It uses the
Protocol Buffers data format for efficient serialization, and supports a variety of programming languages. This
framework offers several features that make it a popular choice for building microservice architectures and large-scale
networked systems, such as bidirectional streaming, flow control, and automatic generation of client and server code.
The efficient and scalable design of gRPC allows developers to create fast and robust APIs, making it a must-have tool
for anyone looking to step up their API game. Whether you're building a microservice or a large-scale system, gRPC
provides a comprehensive solution that will help you achieve your goals efficiently and effectively.

## Prerequisites

* You'll need one of the [last two major releases][go-releases] of Go, with a minimum of Go 1.18. See
  Go's [Getting Started][install-go] guide for installation instructions.

## Install tools

First, we'll need to install some code generation tools:

```terminal
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
```

`protoc-gen-go-grpc` is a plugin for the Google protocol buffer compiler to generate gRPC stubs in Go.

## 1. Generate code

We're going to generate our code using [Buf][buf], a modern replacement for Google's protobuf compiler. We installed Buf
earlier, but we also need a few configuration files to get going. (If you'd prefer, you can skip this section and
use `protoc` instead &mdash; `protoc-gen-grpc-go` behaves like any other plugin.)

Next, tell Buf how to generate code by putting this into [`buf.gen.yaml`][buf.gen.yaml]:

```yaml
version: v1
plugins:
  - name: go
    out: gen
    opt: paths=source_relative
  - name: go-grpc
    out: gen
    opt: paths=source_relative
```

With our configuration files in place, you can generate code:

```terminal
$ buf generate
```

In your `gen` directory, you should now see some generated Go:

```
gen
â””â”€â”€ greet
    â””â”€â”€ v1
        â”œâ”€â”€ greet.pb.go
        â””â”€â”€ greet_grpc.pb.go
```

The package `gen/greet/v1` contains `greet.pb.go`, which was generated by Google's `protoc-gen-go`, and it contains
the `GreetRequest` and `GreetResponse` structs and the associated marshaling code. The
package `gen/greet/v1/` contains `greet_grpc.pb.go`, which was generated by `protoc-gen-grpc-go`, and
it contains the gRPC handler and client interfaces and constructors.

:::caution ðŸš§ Under construction
include comment about virtually unreadable generated code
:::

## 1. Implement the server {#implement-the-server}

You can start implementing a server by creating a `server/main.go` file:

```terminal
$ mkdir server
$ touch server/main.go
```

Copy and paste this content into that file:

```go title="server/main.go"
package main

import (
	"context"
	"fmt"
	"log"
	"net"

	"google.golang.org/grpc/reflection"

	// This import path is based on the name declaration in the go.mod,
	// and the gen/ output location in the buf.gen.yaml.
	greetv1 "example/gen/greet/v1"
	"google.golang.org/grpc"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	listenOn := "127.0.0.1:8080"
	listener, err := net.Listen("tcp", listenOn)
	if err != nil {
		return fmt.Errorf("failed to listen on %s: %w", listenOn, err)
	}

	server := grpc.NewServer()
	reflection.Register(server)
	greetv1.RegisterGreetServiceServer(server, &greetServiceServer{})
	log.Println("Listening on", listenOn)
	if err := server.Serve(listener); err != nil {
		return fmt.Errorf("failed to serve gRPC server: %w", err)
	}

	return nil
}

// greetServiceServer implements the GreetService API.
type greetServiceServer struct {
	greetv1.UnimplementedGreetServiceServer
}

// Greet ..
func (s *greetServiceServer) Greet(_ context.Context, req *greetv1.GreetRequest) (*greetv1.GreetResponse, error) {
	name := req.GetName()
	log.Println("Greeting received from", name)

	return &greetv1.GreetResponse{
		Greeting: fmt.Sprintf("Hello, %s!", name),
	}, nil
}
```

## 1. Resolve Go dependencies {#resolve-go-dependencies}

Now that you have code for a server, run this command to
resolve some of the dependencies you need for the generated code:

```terminal
$ go mod tidy
```

You should notice these changes (the version pins may differ):

```sh title="go.mod" {4-9}
module example

go 1.20

require (
	google.golang.org/grpc v1.53.0
	google.golang.org/protobuf v1.28.1
)

require (
	github.com/golang/protobuf v1.5.2 // indirect
	golang.org/x/net v0.5.0 // indirect
	golang.org/x/sys v0.4.0 // indirect
	golang.org/x/text v0.6.0 // indirect
	google.golang.org/genproto v0.0.0-20230110181048-76db0878b65f // indirect
)
```

## 1. Run your server

:::caution ðŸš§ UNDER CONSTRUCTION
add on ramp
:::

```terminal
$ go run server/main.go
---
... Listening on 127.0.0.1:8080
```

:::caution ðŸš§ UNDER CONSTRUCTION
add bridge
:::

```terminal
grpcurl -plaintext \
  -d '{"name": "Alice"}' \
  127.0.0.1:8080 greet.v1.GreetService/Greet
---
{
  "greeting": "Hello, Alice!"
}
```

:::caution ðŸš§ UNDER CONSTRUCTION
add off ramp
:::

## 1. Implement the client {#implement-the-client}

You can start implementing a client by creating a `client/main.go` file:

```terminal
$ mkdir client
$ touch client/main.go
```

Copy and paste this content into that file:

```go title="client/main.go"
package main

import (
	"context"
	"fmt"
	"log"

	// This import path is based on the name declaration in the go.mod,
	// and the gen/ output location in the buf.gen.yaml.
	greetv1 "example/gen/greet/v1"
	"google.golang.org/grpc"
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	connectTo := "127.0.0.1:8080"
	conn, err := grpc.Dial(connectTo, grpc.WithBlock(), grpc.WithInsecure())
	if err != nil {
		return fmt.Errorf("failed to connect to GreetService on %s: %w", connectTo, err)
	}
	log.Println("Connected to", connectTo)

	api := greetv1.NewGreetServiceClient(conn)
	if _, err := api.Greet(context.Background(), &greetv1.GreetRequest{
		Name: "Alica",
	}); err != nil {
		return fmt.Errorf("failed to Greet: %w", err)
	}

	log.Println("Successfully Greet")
	return nil
}
```

## 1. Call `Greet` {#call-greet}

With the `server/main.go` and `client/main.go` implementations shown above, run the server and call the `Greet` endpoint
from the client.

First, run the server:

```terminal
$ go run server/main.go
---
... Listening on 127.0.0.1:8080
```

In a separate terminal, run the client, and you should see a success message:

```terminal
$ go run client/main.go
---
... Connected to 127.0.0.1:8080
... Successfully Greet
```

You'll also notice this in the server logs (in the other terminal running the server):

```terminal
$ go run server/main.go
---
... Listening on 127.0.0.1:8080
... Greeting received from Alice
```

## Next steps

Now that you've successfully created a gRPC server and client with Buf...

Next you will consider a simpler protocol, Connect, to build your application  

import Feedback from './_feedback.mdx';

<Feedback/>