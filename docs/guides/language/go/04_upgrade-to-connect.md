---
sidebar_position: 4
id: upgrade-to-connect
title: Upgrade to Connect
description: "Transform Your Go API Building Game with Buf: Create Lightning-Fast, Efficient, and Effortless APIs in
Just 15 Minutes!"
---

Connect is a slim library for building browser- and gRPC-compatible HTTP APIs. You define your service with a Protocol
Buffer schema, and Connect generates type-safe server and client code. Fill in your server's business logic, and you're
done &mdash; no handwritten marshaling, routing, or client code required!

This fifteen-minute walkthrough helps you create a small Connect service in Go. It demonstrates what you'll be writing
by hand, what Connect generates for you, and how to call your new API.

## Prerequisites

* You'll need one of the [last two major releases][go-releases] of Go, with a minimum of Go 1.18. See
  Go's [Getting Started][install-go] guide for installation instructions.

## Install tools

First, we'll need to create a new Go module and install some code generation tools:

```terminal
$ go install github.com/bufbuild/connect-go/cmd/protoc-gen-connect-go@latest
```

## 1. Generate Code

We're going to generate our code using [Buf][buf], a modern replacement for Google's protobuf compiler. We installed Buf
earlier, but we also need a few configuration files to get going. (If you'd prefer, you can skip this section and
use `protoc` instead &mdash; `protoc-gen-connect-go` behaves like any other plugin.)

First, scaffold a basic [`buf.yaml`][buf.yaml] by running `buf mod init`. Next, tell Buf how to generate code by putting
this into[`buf.gen.yaml`][buf.gen.yaml]:

```yaml
version: v1
plugins:
  - name: go
    out: gen
    opt: paths=source_relative
  - name: connect-go
    out: gen
    opt: paths=source_relative
```

With those configuration files in place, you can generate code:

```bash
$ buf generate
```

In your `gen` directory, you should now see some generated Go:

```
gen
â””â”€â”€ greet
    â””â”€â”€ v1
        â”œâ”€â”€ greet.pb.go
        â””â”€â”€ greetv1connect
            â””â”€â”€ greet.connect.go
```

The package `gen/greet/v1` contains `greet.pb.go`, which was generated by Google's `protoc-gen-go`, and it contains
the `GreetRequest` and `GreetResponse` structs and the associated marshaling code. The
package `gen/greet/v1/greetv1connect` contains `greet.connect.go`, which was generated by `protoc-gen-connect-go`, and
it contains the HTTP handler and client interfaces and constructors. Feel free to poke around if you're interested
&mdash; `greet.connect.go` is less than 100 lines of code, including comments.

## 1. Implement handler

The code we've generated takes care of the boring boilerplate, but we still need to implement our greeting logic. In the
generated code, this is represented as the `greetv1connect.GreetServiceHandler` interface. Since the interface is so
small, we can do everything in one Go package. `mkdir -p cmd/server`, then add `cmd/server/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"

	"github.com/bufbuild/connect-go"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	greetv1 "example/gen/greet/v1" // generated by protoc-gen-go
	"example/gen/greet/v1/greetv1connect" // generated by protoc-gen-connect-go
)

type GreetServer struct{}

func (s *GreetServer) Greet(
	ctx context.Context,
	req *connect.Request[greetv1.GreetRequest],
) (*connect.Response[greetv1.GreetResponse], error) {
	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&greetv1.GreetResponse{
		Greeting: fmt.Sprintf("Hello, %s!", req.Msg.Name),
	})
	res.Header().Set("Greet-Version", "v1")
	return res, nil
}

func main() {
	greeter := &GreetServer{}
	mux := http.NewServeMux()
	path, handler := greetv1connect.NewGreetServiceHandler(greeter)
	mux.Handle(path, handler)
	http.ListenAndServe(
		"localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
}
```

As you've probably noticed, the `Greet` method uses generics: the `connect.Request` and `connect.Response` types offer
direct access to headers and trailers, while still providing strongly-typed access to the
generated `greetv1.GreetRequest` and `greetv1.GreetResponse` structs. Generics simplify many portions of Connect, and
even let advanced users skip using `protoc-gen-connect-go`.

In a separate terminal window, you can now update `go.mod` and start your server:

```terminal
$ go get golang.org/x/net/http2
$ go get github.com/bufbuild/connect-go
$ go run ./cmd/server/main.go
```

## 1. Make requests

The simplest way to consume your new API is an HTTP/1.1 POST with a JSON payload. If you have a recent version of cURL
installed, it's a one-liner:

```terminal
$ curl \
    --header "Content-Type: application/json" \
    --data '{"name": "Jane"}' \
    http://localhost:8080/greet.v1.GreetService/Greet
---
{"greeting": "Hello, Jane!"}
```

Your new handler automatically supports gRPC requests, too:

```terminal
$ grpcurl \
    -protoset <(buf build -o -) -plaintext \
    -d '{"name": "Jane"}' \
    localhost:8080 greet.v1.GreetService/Greet
---
{
  "greeting": "Hello, Jane!"
}
```

We can also make requests using Connect's generated client. `mkdir -p cmd/client` and put this in `cmd/client/main.go`:

```go
package main

import (
	"context"
	"log"
	"net/http"

	greetv1 "example/gen/greet/v1"
	"example/gen/greet/v1/greetv1connect"

	"github.com/bufbuild/connect-go"
)

func main() {
	client := greetv1connect.NewGreetServiceClient(
		http.DefaultClient,
		"http://localhost:8080",
	)
	res, err := client.Greet(
		context.Background(),
		connect.NewRequest(&greetv1.GreetRequest{Name: "Jane"}),
	)
	if err != nil {
		log.Println(err)
		return
	}
	log.Println(res.Msg.Greeting)
}
```

With your server still running in a separate terminal window, you can now run
your client:

```terminal
$ go run ./cmd/client/main.go
```

Congratulations &mdash; you've built your first Connect service! ðŸŽ‰

## 1. Use the gRPC protocol instead of the Connect protocol

`connect-go` supports three protocols:

- The gRPC protocol that is used throughout the gRPC ecosystem, making `connect-go` [compatible][] with other gRPC
  implementations out of the box. `grpc-go` clients will work with `connect-go` servers and vice versa without issue -
  in fact, before `connect-go`'s public release, this is exactly what the [Buf CLI][buf-cli] was doing.
- The gRPC-Web protocol used by [grpc/grpc-web][grpc-web], allowing `connect-go` servers to interop with `grpc-web`
  frontends without the need for an intermediary proxy (such as Envoy).
- The new [Connect protocol][], a simple, POST-only protocol that works over HTTP/1.1 or HTTP/2. It takes the best
  portions of gRPC and gRPC-Web, including streaming, and packages them into a protocol that works equally well in
  browsers, monoliths, and microservices. The Connect protocol is what we think the gRPC protocol should be. By default,
  JSON- and binary-encoded Protobuf is supported.

By default, `connect-go` servers support ingress from all three protocols without any configuration. `connect-go`
clients use the Connect protocol by default, but can use either the gRPC or gRPC-Web protocols by setting the `WithGRPC`
or `WithGRPCWeb` client options.

Edit `cmd/client/main.go` above to create the `GreetServiceClient` using the `WithGRPC` option:

```go
client := greetv1connect.NewGreetServiceClient(
  http.DefaultClient,
  "http://localhost:8080",
  //highlight-next-line
  connect.WithGRPC(),
)
```

With your server still running in a separate terminal window, run the client one more time:

```terminal
$ go run ./cmd/client/main.go
```

Your output should remain the same, but `connect-go` is now using the gRPC protocol instead of the Connect protocol to
communicate over the wire.

## So what?

With just a few lines of handwritten code, you've built a real API server that supports both the gRPC and Connect
protocols. Unlike a handwritten REST service, you didn't need to design a URL hierarchy, hand-write request and response
structs, manage your own marshaling, or parse typed values out of query parameters. More importantly, your users got an
idiomatic, type-safe client without *any* extra work on your part.

import Feedback from './_feedback.mdx';

<Feedback/>

[buf]: https://buf.build/

[buf.gen.yaml]: https://docs.buf.build/configuration/v1/buf-gen-yaml

[buf.yaml]: https://docs.buf.build/configuration/v1/buf-yaml

[buf-cli]: https://github.com/bufbuild/buf

[cURL]: https://curl.se/

[godoc]: https://pkg.go.dev/github.com/bufbuild/connect-go

[go-releases]: https://golang.org/doc/devel/release

[grpc-web]: https://github.com/grpc/grpc-web

[install-go]: https://golang.org/doc/install

[protobuf]: https://developers.google.com/protocol-buffers
